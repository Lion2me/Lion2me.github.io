---

layout: post
title: 데이터 중심 애플리케이션 설계 - 일관성과 합의
date: 2022-12-08 21:05:23 +0900
category: DE
use_math: true

---

이 글은 Martin Kleppmann의 데이터 중심 애플리케이션 설계를 읽고 기억하고자 적는 게시글입니다.

# 9. 일관성과 합의

8장에서 공부 한 내용처럼 분산 환경에서는 많은 골칫거리가 있습니다. 이러한 점을 대처하여 내결함성을 가진 분산 시스템을 구축 할 필요가 있는데, 이번에 그 알고리즘에 대해 알아보았습니다.

내결함성을 보장하는 가장 좋은 방법은 **범용 추상화**를 구현하여 애플리케이션이 이 보장에 의존하게 하는 것입니다. 예를 들면 트랜잭션이라고 볼 수 있습니다. 트랜잭션 자체가 장애(원자성) 혹은 충돌(독립성) 등을 방지하면서 애플리케이션이 걱정하지 않게 해줍니다.

이러한 방식을 계속 사용해서 분산 시스템에서는 **합의**라는 추상화를 추가적으로 갖습니다. 어떤 동작이든 **모든 노드가 동의하게 하는 것**으로써 네트워크 결함 혹은 장애 등에 신뢰성있게 합의가 되면 반영하게 되면 완벽합니다. 매우 어렵지만요.

## 일관성

이전에 비동기적 분산 데이터베이스는 **최종적 일관성**을 갖는 것으로 만족한다고 알 고 있습니다. 이 뜻은 데이터를 저장했을 때 바로 데이터를 읽을 수 있는지는 명확하지 않지만 **결국에는 데이터가 성공적으로 입력 될 것**이라고 생각하는 것이라고 공부했습니다.

이러한 **약한 보장**은 시스템에 결함이 있거나, 동시성이 높을 때 문제가 발생 할 수 있다고 합니다.

## 선형성

최종적 일관성을 약한 보장이라고 말했다면, 반대로 강한 보장이 등장해야 합니다.

**데이터를 쓰고 난 후 읽었을 때 해당 데이터를 무조건 읽을 수 있는 것**을 보장하는 단계가 바로 선형성입니다. 그리고 이러한 동작의 조건으로 **데이터 복사본이 하나만 존재하는 것 처럼** 보이면 된다고 합니다.

이해하기 쉽게 A 저장소만 있다면 모든 유저가 A에서만 읽고 쓰기 때문에 항상 같은 결과를 읽을 거라는 이야기입니다.

<img src="/assets/img/notlinear.png" width="700" height="400">

그림은 선형성에 대해 명확하게 나타내고 있습니다. **각 읽기가 동작 할 때 쓰기의 어느 시점에 쓰여지는지는 명확하지 않기 때문에 쓰기 연산의 전후 값 중 어떤 값이 나올지는 모르지만, 적어도 이전에 반영 된 새로운 값이 읽어졌다면, 이후의 읽기에서도 반영 된 새로운 값이 등장해야 한다는 의미**입니다.

헷갈릴 수 있는 특성인 직렬성은 **트랜잭션이 같은 객체에 접근 할 때 독립적으로 연산하여 어느 순서에 따라 동작하도록 보장하는** 특성이 있는데, 여기서는 **정확한 순서**를 보장하지 않기 때문에 요청의 순서에 따라 동작하는 선형성보다는 약한 형태입니다.

### 1. 선형성이 필요한 곳

#### 1) 잠금

데이터를 잠금에 있어서 선형성은 필요합니다. 왜냐하면 잠금이 선형적이지 않으면, 점유하고 있는 데이터에 대해 다른 노드가 접근 할 수 있고 이로인해 데이터가 유실 될 가능성이 있습니다.

#### 2) 리더 선출

리더 선출에 선형성이 보장되지 않는다면, 리더가 여러 개인 스플릿 브레인 현상이 발생하고 이 경우 마찬가지로 데이터가 덮어씌워지는 등 데이터 유실이 발생 할 수 있습니다.

#### 3) 제약조건과 유일성 보장

만약 유저의 고유 ID와 같은 특정 ID에 대해서 유일성을 보장해야 한다면 선형성은 필수적입니다. 혹은 은행 계좌의 프로그램은 음수가 되지 않아야하는 제약조건을 엄중하게 관리 할 필요가 있습니다. 이런 경우에도 선형성이 필수적입니다.

#### 4) 채널 간 타이밍 의존성

어려운 말이지만 결국 **다음 동작 전 이전까지의 데이터가 정확하게 입력 되어야 한다는 것**입니다. 예를 들면 관련 상품을 추천해주는 알고리즘은 유저의 최근 조회 상품 정보를 입력 받아야 결과를 낼 수 있다고 할 때, 알고리즘 시작 전 조회 정보가 입력되어 있어야 합니다.

### 2. 선형성 구현

내결함성을 갖기 위해 복제를 채택하는 방식중에서 선형성관 연관지어 보면 다음과 같습니다.

1. 단일 리더 복제 - 동기식이면 선형성을 가질 수 있음
2. 합의 알고리즘 - 선형적
3. 다중 리더 복제 - 비선형적
4. 리더 없는 복제 - 시간을 이용해도 타임스탬프가 밀릴 수 있고, 느슨한 정족수는 비선형적일 가능성이 높음

### 3. 선형성의 비용

들으면 들을수록 선형성은 장점만 있는 것 같지만 어느정도의 트레이드 오프는 감안해야 합니다. 선형적인 애플리케이션인 단일 복제 노드는 팔로워 노드와 리더 노드와의 연결이 끊기면 팔로워 노드에 접근한 클라이언트는 새로 쓰여진 데이터에 접근 할 수 없습니다.

하지만 비선형적인 다중 복제의 경우에는 다른 데이터센터에서 독립적으로 데이터를 다루기 때문에 이러한 문제에 강합니다.

즉 **선형적인 프로그램은 (네트워크 장애의 발생 가능성이 있는 한) 가용성이 없다고** 말할 수 있습니다. 또한 **선형적인 프로그램은 성능도 상대적으로 낮습니다**

## 순서화

순서화는 **연산이 잘 정의 된 순서대로 실행**됨을 말하며 이는 곧 **순서화가 선형성의 기반**이라는 것을 알 수 있습니다. 그리고 순서화는 **인과성**을 보장해주기도 합니다.

여기서 인과성은 쉽게 말하면 질문에 대한 답은 질문을 듣고 나서 할 수 있다는 말로 생각할 수 있습니다.








## 참고


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
